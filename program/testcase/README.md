# 测试场景说明

对测试场景的期望结果进行说明



## testcase 1

使用 3 个拨码开关用于测试用例的编号输入，8 或 16 个拨码开关用于做测试数据的输入，用 led 输出操作数的二进制形式，用 7 段数码管输出运算结果的十六进制形式

| 编号   | 用例描述                                                     |
| ------ | ------------------------------------------------------------ |
| 3'b000 | 输入测试数 a，输入测试数 b，在输出设备 (led) 上展示 8 bit 的 a 和 b 的值 |
| 3'b001 | 输入测试数 a，以 `lb` 的方式放入某个寄存器，将该 32 位的寄存器的值以十六进制的方式展示在输出设备上 (数码管)，并将该数保存到内存中 (在 3’b011 - 3’b111 用例中，将通过 `lw` 指令从该内存单元中读取 a 的值进行比较) |
| 3'b010 | 输入测试数 b，以 `lbu` 的方式放入某个寄存器，将该 32 位的寄存器的值以十六进制的方式展示在输出设备上 (数码管)，并将该数保存到内存中 (在 3’b011 - 3’b111 用例中，将通过 `lw` 指令从该内存单元中读取 b 的值进行比较) |
| 3'b011 | 用 `beq` 比较测试数 a 和测试数 b，如果关系成立，点亮 led，关系不成立，led 熄灭 |
| 3'b100 | 用 `blt` 比较测试数 a 和测试数 b，如果关系成立，点亮 led，关系不成立，led 熄灭 |
| 3'b101 | 用 `bge` 比较测试数 a 和测试数 b，如果关系成立，点亮 led，关系不成立，led 熄灭 |
| 3'b110 | 用 `bltu` 比较测试数 a 和测试数 b，如果关系成立，点亮 led，关系不成立，led 熄灭 |
| 3'b111 | 用 `bgeu` 比较测试数 a 和测试数 b，如果关系成立，点亮 led，关系不成立，led 熄灭 |

### case 0

| sw1      | sw2      | led1     | led2     |
| -------- | -------- | -------- | -------- |
| 00001111 | 00001111 | 00001111 | 00001111 |
| 11110000 | 00001110 | 11110000 | 00001110 |
| 00000111 | 00011111 | 00000111 | 00011111 |

### case 1

| sw1      | sw2      | 数码管     |
| -------- | -------- | ---------- |
| 00001111 | XXXXXXXX | 0x0000000F |
| 11110000 | XXXXXXXX | 0xFFFFFFF0 |
| 00000111 | XXXXXXXX | 0x00000007 |

### case 2

| sw1      | sw2      | 数码管     |
| -------- | -------- | ---------- |
| XXXXXXXX | 00001111 | 0x0000000F |
| XXXXXXXX | 00001110 | 0x0000000E |
| XXXXXXXX | 00011111 | 0x0000001F |

### case 3 - 7

| a        | b        | `beq` | `blt` | `bge` | `bltu` | `bgeu` |
| -------- | -------- | ----- | ----- | ----- | ------ | ------ |
| 00001111 | 00001111 | 1     | 0     | 1     | 0      | 1      |
| 11110000 | 00001110 | 0     | 1     | 0     | 0      | 1      |
| 00000111 | 00011111 | 0     | 1     | 0     | 1      | 0      |



## testcase 2

使用 3 个拨码开关用于测试用例的编号输入，8 或 16 个拨码开关用于做测试数据的输入，用 led 输出操作数的二进制形式，用 7 段数码管输出运算结果的十六进制形式

| 编号   | 用例描述                                                     |
| ------ | ------------------------------------------------------------ |
| 3'b000 | 输入一个 8 bit 的数，计算并输出其前导零的个数                |
| 3'b001 | 输入 16 bit 位宽的 IEEE 754 编码的半字浮点数 ，对其进行向上取整，输出取整后的结果 |
| 3'b010 | 输入 16 bit 位宽的 IEEE 754 编码的半字浮点数 ，对其进行向下取整，输出取整后的结果 |
| 3'b011 | 输入 16 bit 位宽的 IEEE 754 编码的半字浮点数 ，对其进行四舍五入取整，输出取整后的结果 |
| 3'b100 | 输入两个 8 bit 数 a 和 b，对 a，b 做加法运算，如果相加和超过 8 bit，将高位取出，累加到相加和中，对相加和取反后输出 |
| 3'b101 | 输入 12 bit 的数据 (前面补 0 成为 32 bit)，以小端模式从拨码开关输入，以大端的方式呈现在输出设备上 |
| 3'b110 | 以递归的方式计算小于输入数据的斐波拉契数字的数目，记录本次入栈和出栈次数，在输出设备上显示入栈和出栈的次数之和 |
| 3'b111 | 以递归的方式计算小于输入数据的斐波拉契数字的数目，记录入栈和出栈的数据，在输出设备上显示入栈的参数，每一个入栈的参数显示停留2-3秒 (此处的输出不关注 ra 的入栈和出栈) |

### case 0

略

### case 1 - 3

| 半字浮点数       | 十进制小数 | 向上取整         | 向下取整         | 四舍五入         |
| ---------------- | ---------- | ---------------- | ---------------- | ---------------- |
| 0100100101100000 | 10.75      | 0x0000000B = 11  | 0x0000000A = 10  | 0x0000000B = 11  |
| 1100100101100000 | -10.75     | 0xFFFFFFF6 = -10 | 0xFFFFFFF5 = -11 | 0xFFFFFFF5 = -11 |
| 0100001001000000 | 3.125      | 0x00000004 = 4   | 0x00000003 = 3   | 0x00000003 = 3   |
| 1100001001000000 | -3.125     | 0xFFFFFFFD = -3  | 0xFFFFFFFC = -4  | 0xFFFFFFFD = -3  |

### case 4

| a (8 bit) | b (8 bit) | a + b (9 bit) | 累加高位 (8 bit) | 取反     |
| --------- | --------- | ------------- | ---------------- | -------- |
| 00110001  | 01000011  | 001110100     | 01110100         | 10001011 |
| 01000011  | 01000000  | 010000011     | 10000011         | 01111100 |
| 10000110  | 10100000  | 100100110     | 00100111         | 11011000 |
| 11111111  | 11111111  | 111111110     | 11111111         | 00000000 |

### case 5

| sw1      | sw2      | 补 0 扩展  | 转换后     |
| -------- | -------- | ---------- | ---------- |
| XXXX0110 | 10110011 | 0x000006B3 | 0xB3060000 |
| XXXX0001 | 01111010 | 0x0000017A | 0x7A010000 |
| XXXX1100 | 00101111 | 0x00000C2F | 0x2F0C0000 |

### case 6

使用以下代码计算斐波那契数列的第 n 项

```assembly
fib:
	addi sp, sp, -12 # adjust stack for 2 items
	sw ra, 4(sp)     # save the return address
	sw a1, 0(sp)     # save the argument n
	slti t0, a1, 2   # test for n < 2
	beq t0, zero, L1 # if n >= 2, go to L1
	addi a1, zero, 1 # else return 1
	addi sp, sp, 12  # pop 2 items off stack
	jr ra            # return to caller
L1:
	addi a1, a1, -1  # n >= 2; argument gets(n-1)
	jal fib          # call fib(n-1)
	sw a1, 8(sp)     # save result for fib(n-1)
	lw a1, 0(sp)     # load n
	addi a1, a1, -2  # n >= 2; argument gets(n-2)
	jal fib          # call fib(n-2)
	lw t1, 8(sp)     # restore fib(n-1)
	add a1, a1, t1   # a1 = fib(n-1) + fib(n-2)
	lw ra, 4(sp)     # restore the return address
	addi sp, sp, 12  # adjust stack pointer to pop 2 items
	jr ra            # return to the caller
```

递归的计算第 n 项时所需的出入栈次数如下表

| n             | 0    | 1    | 2    | 3    | 4    | ...  | k                   |
| ------------- | ---- | ---- | ---- | ---- | ---- | ---- | ------------------- |
| **次数 t(n)** | 4    | 4    | 14   | 24   | 44   | ...  | t(k-1) + t(k-2) + 6 |

采用以下代码计算小于某数的斐波那契数列中的项数

```assembly
	li t5,0
	li t6,0
loop:
	addi a1,t6,0
	jal fib
	addi t6,t6,1
	blt a1,a2,loop
	j loop
```

在上述循环中，会计算到大于等于给定数的斐波那契数列中的项，因此输入参数与出入栈次数的关系如下表

| 输入参数 | 计算到的项数 | 数列中元素的值 | 累计出入栈次数  |
| -------- | ------------ | -------------- | --------------- |
| 0        | 0            | 1              | 4               |
| 1        | 0            | 1              | 4               |
| 2        | 2            | 2              | 4+4+14=22       |
| 3        | 3            | 3              | 4+4+14+24=46    |
| 4, 5     | 4            | 5              | 4+4+14+24+44=90 |
| ...      | ...          | ...            | ...             |

### case 7

递归的计算第 n 项时入栈参数如下

| n    | 入栈参数 list(n)                      |
| ---- | ------------------------------------- |
| 0    | 0                                     |
| 1    | 1                                     |
| 2    | 2, 1, 1, 0                            |
| 3    | 3, 2, 1, 1, 0, 2, 1                   |
| 4    | 4, 3, 2, 1, 1, 0, 2, 1, 3, 2, 1, 1, 0 |
| ...  | ...                                   |
| k    | k, list(k-1), f(k-1), list(k-2)       |

因此参考 case 6 的循环计算方式，入栈参数即为 n 从 0 到计算到的项数的入栈参数的拼接

| 输入参数 | 入栈参数                                                     |
| -------- | ------------------------------------------------------------ |
| 0        | 0                                                            |
| 1        | 0                                                            |
| 2        | 0, 1, 2, 1, 1, 0                                             |
| 3        | 0, 1, 2, 1, 1, 0, 3, 2, 1, 1, 0, 2, 1                        |
| 4        | 0, 1, 2, 1, 1, 0, 3, 2, 1, 1, 0, 2, 1, 4, 3, 2, 1, 1, 0, 2, 1, 3, 2, 1, 1, 0 |
| ...      | ...                                                          |

